Вариант 1. Жадный алгоритм для вершинного покрытия
Задача: реализовать жадный 2-аппроксимационный алгоритм для задачи о вершинном
покрытии. Входные данные представляют собой граф, заданный списком ребер. Необходимо
найти множество вершин, таких что каждое ребро имеет хотя бы один конец в этом множестве.
16
Требования:
- Реализовать алгоритм на всех трех языках (Python, C++, Java)
- Проверить корректность решения
- Вывести размер найденного покрытия и само покрытие
- Оценить коэффициент аппроксимации (должен быть ≤ 2)
Входные данные:
Граф с 10 вершинами (0-9) и следующими ребрами:
(0,1), (1,2), (2,3), (3,4), (4,5), (5,6), (6,7), (7,8), (8,9), (9,0)

Анализ работы алгоритма:
Создание множества вершин (vertices): используется цикл for для добавления всех вершин из списка ребер в множество vertices.
Жадный выбор вершин (while edges): пока остаются непокрытые ребра, выбираем вершину с максимальной степенью (количество непокрытых ребер, связанных с ней).
Удаление покрытых ребер (edges = [(u, v) for u, v in edges if u != best_vertex and v != best_vertex]): после добавления вершины удаляем все ребра, которые теперь покрыты.
Продолжаем, пока все ребра не будут покрыты.

Временная сложность: O(m*n), где m - количество ребер, а n - количество вершин.
Почему: На каждой итерации цикла while требуется пройти по всем ребрам для вычисления степени вершин.
Количество итераций зависит от количества вершин, так как каждая вершина может быть добавлена в покрытие только один раз.


Контрольный вопрос:
Задание 1. Жадный алгоритм: размен монет
Условие. Даны номиналы монет и сумма S. Найти минимальное число монет для размена
(жадный подход).
Алгоритм: жадный выбор по наибольшему номиналу.
Язык примера: Python
def min_coins(coins, S):
 coins.sort(reverse=True)
 count = 0
 for coin in coins:
 # ДОПИСАТЬ: сколько монет номиналом coin можно взять
 return count
Что дописать: цикл взятия максимального числа монет каждого номинала.

Ответ(дополненный код):
def min_coins(coins, S):
    coins.sort(reverse=True)
    count = 0
    for coin in coins:
        num_coins = S // coin
        count += num_coins
        S -= num_coins * coin
    return count

Результат работы кода при входных данных coins = [1, 5, 10, 25], S = 63:
Минимальное количество монет: 6
