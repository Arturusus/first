Контрольная работа

Блочная(корзинная) сортировка

Определение:
Блочная сортировка - это алгоритм, который распределяет элементы исходного массива на несколько блоков (корзин) в зависимости от диапазона их
значений. После этого каждая корзина сортируется отдельно (либо тем же методом
рекурсивно, либо другим алгоритмом, например, вставками), и отсортированные корзины
объединяются обратно в один массив.

Анализ:
Делим массив на баки:Используем оператор std::vector<std::vector<T>>(), чтобы создать вектор контейнеров (баков), где каждый бак — это будущий мини-массив для сортировки.
Распределяем элементы по бакам:В цикле for пробегаем по массиву и размещаем каждый элемент в соответствующий бак, вычисляя его принадлежность через простую формулу.
Сортируем каждый бак:Применяем функцию std::sort() к каждому баку, чтобы отсортировать его локально.
Складываем отсортированные элементы обратно в массив:Итоговый цикл собирает отсортированные элементы из каждого бака обратно в исходный массив.

Временная сложность: O(n+k), где n — количество элементов массива, k — количество созданных баков.
Почему: Первым делом мы распределяем элементы по бакам за время O(n).
Затем каждый бак сортируется отдельно, и если баки сравнительно небольшого размера, то на это уходит примерно O(k).
На завершающем этапе мы снова пробегаем по всем бакам и собираем элементы обратно в массив, что добавляет еще 
O(n).

Сортировка бусинами(гравитационная)

Определение:
Сортировка бусинами (bead sort), также известная как гравитационная
сортировка, моделирует естественное поведение бусин, падающих вниз под действием
гравитации. 

Анализ:
Находим максимальную высоту:Используем оператор std::max_element() для поиска наибольшего числа в массиве.
Создаем матрицу бусин:Оператор std::vector<std::vector<bool>>() строит матрицу, где каждый столбец — элемент массива, а высота столбца — значение элемента.
Заполняем матрицу бусин:Вложенные циклы for размечают матрицу в соответствии с числами массива.
Имитация падения бусин:Следующие циклы моделируют движение бусин вниз, устанавливая их на нужные позиции.
Восстанавливаем отсортированный массив:Последний цикл собирает количество бусин в каждом столбце, создавая отсортированный массив.

Временная сложность: O(n*(k^0.5)), где n — количество элементов массива, k — разница между максимальным и минимальным значениями.
Почему: Визуально алгоритм кажется быстрым, так как бусины мгновенно стабилизируются, но фактически сложность зависит от диапазона значений.
Для каждого элемента требуется организовать "падение" бусин, что приводит к временным затратам, зависящим от диапазона данных.


Поиск скачками

Определение:
Поиск скачками - это оптимизация линейного поиска для отсортированных массивов, при
которой алгоритм «прыгает» через определённое число элементов (обычно через n), чтобы
быстро сузить диапазон поиска, а затем выполняет линейный поиск внутри найденного
диапазона.

Анализ:
Рассчитываем оптимальный шаг прыжков:Используем оператор std::sqrt(size), чтобы вычислить шаг прыжков (примерно квадратный корень из размера массива).
Прыгаем по массиву:В цикле while прыгаем большими шагами, пока не найдём блок, где находится искомый элемент.
Линейный поиск в блоке:Как только найден подходящий блок, запускаем линейный поиск с помощью цикла for, чтобы точно определить местонахождение элемента.
Проверка результата:Если элемент найден, возвращаем его индекс, иначе возвращаем -1.

Временная сложность: O(n^0.5)
Почему: Алгоритм состоит из двух фаз: прыжки по массиву и линейный поиск внутри блока.
Первая фаза (скачки) выполняется примерно за O(n^0.5) шагов. Вторая фаза (линейный поиск) также выполняется за O(n^0.5) шагов, так как максимальный размер блока ограничен размером шага.


Экспоненциальный поиск

Определение:
Экспоненциальный поиск сочетает идеи последовательного и бинарного поиска, позволяя
быстро определить диапазон, в котором может находиться искомое значение, а затем
применяет двоичный поиск в этом диапазоне.

Анализ:
Сначала проверяем базовые условия:Используем условные конструкции, чтобы убедиться, что массив не пуст и первый элемент не больше искомого значения.
Определяем стартовый диапазон:С помощью оператора while удваиваем диапазон поиска до тех пор, пока не обнаружим, что текущий элемент массива стал больше искомого.
Применяем бинарный поиск:После нахождения подходящего диапазона используем классический бинарный поиск для точной локализации элемента.
Проверка результата:Если элемент найден, возвращаем его индекс, иначе возвращаем -1.

Временная сложность: O(logn)
Почему: Вначале алгоритм экспоненциально расширяет диапазон поиска, что выполняется за O(logn) шагов.
Затем выполняется бинарный поиск в найденном диапазоне, который также выполняется за O(logn) шагов.


Тернарный поиск

Определение:
Тернарный поиск — это метод деления диапазона поиска на три части (в отличие от двух в
бинарном) и рекурсивного сужения диапазона до тех пор, пока не будет найден элемент или
экстремум функции (в зависимости от задачи).

Анализ:
Определяем шаг поиска:Используем оператор while(r-l > 2) для контроля точности поиска, пока длина отрезка больше двух.
Делим интервал на три части:Вычисляем две точки, которые делят интервал на три равные части: m1 = l + (r - l) / 3 и m2 = r - (r - l) / 3.
Сужаем интервал поиска:Сравниваем значения функции в точках m1 и m2, и сужаем интервал поиска в зависимости от результата сравнения.
Линейный поиск остатков:Когда интервал становится маленьким, применяем простой линейный поиск для точного нахождения оптимального значения.
Возвращаем результат:Функция возвращает позицию, где функция достигает своего минимума (или максимума, в зависимости от постановки задачи).

Временная сложность: O(log3(n))
Почему: Алгоритм делит интервал на три равные части на каждом шаге, уменьшая длину интервала втрое.
Это приводит к логарифмической сложности, связанной с основанием 3: (O(log 3n).
