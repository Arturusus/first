Абкарян Артур Арменович

Структуры данных.
Лабораторная работа №1:

Структура: массив/список

В Python:
Списки - list - встроенный изменяемый тип данных
Срезы - [::2] - мощный инструмент для работы с подмассивами
Оператор del - удаление объектов из памяти

В Java:
Массивы - String[], int[] - фиксированного размера, для базовых операций
ArrayList из пакета java.util - основной аналог Python списков, динамический массив
Arrays утилитный класс - для работы с массивами (сортировка, поиск, преобразования)
StringBuilder - для эффективной работы со строками
Циклы for и условия if - вместо срезов используются циклы с проверкой индексов

В C++:
vector из <vector> - основной динамический массив, аналог Python list
array из <array> - статический массив с известным размером
string из <string> - для работы со строками
Циклы for с доступом по индексу - замена питоновским срезам
Методы push_back(), clear() - аналоги append() и del в Python

Структура: Стек (LIFO)

В Python:
deque из collections - оптимизированная двусторонняя очередь

В Java:
Deque с реализациями ArrayDeque и LinkedList
Методы push(), pop(), peek() - основные операции стека
LinkedList - можно использовать как стек через методы addFirst(), removeFirst()

В C++:
stack адаптер из <stack> - стандартная реализация стека
vector с методами push_back() и pop_back() - может использоваться как стек
deque из <deque> - двусторонняя очередь, подходит для реализации стека
Методы push(), pop(), top() - основные операции в stack

Структура: Связный список

В Python:
Реализация через классы - ручное создание узлов (Node) и связей
Атрибуты data и next - хранение данных и ссылки на следующий элемент
Методы push(), pop() - операции со стеком на связном списке

В Java:
LinkedList из java.util - готовая реализация двусвязного списка
Поля data и next - аналогично Python, но с строгой типизацией
Методы addFirst(), removeFirst() - операции для работы как стек/очередь

В C++:
list из <list> - стандартная реализация двусвязного списка
Указатели next вместо ссылок - работа с динамической памятью
Оператор new/delete - управление памятью для узлов списка
Методы push_front(), pop_front() - аналоги питоновским операциям



Лабораторная работа №2:

Структура: Мультисписок (вложенный список)

В Python:
Вложенные списки [[], [], []] - списки внутри списков
Циклы for вложенные - для обхода всех уровней
Метод extend() - для разворачивания вложенных списков

В Java:
ArrayList<ArrayList<>> - для создания вложенных списков
Вложенные циклы for - аналогично Python для обхода
Метод addAll() у ArrayList - аналог extend() в Python
Пакет java.util - содержит все необходимые классы коллекций

В C++:
vector<vector<>> - вложенные векторы как аналог вложенных списков
Вложенные циклы for - для обработки многомерных данных
Метод insert() - для объединения векторов
Библиотека <vector> - основной инструмент для работы с динамическими массивами

Структура: Очередь/Дек

В Python:
Queue из queue - классическая очередь FIFO
deque из collections - оптимизированная двусторонняя очередь

В Java:
Queue с реализацией LinkedList - для обычных очередей
Deque с реализацией ArrayDeque - для двусторонних очередей
Методы offer()/poll() - добавление/извлечение из очереди
Методы addFirst()/addLast() - для работы с деком с двух сторон

В C++:
queue из <queue> - стандартная очередь FIFO
deque из <deque> - двусторонняя очередь
Методы push()/pop() - базовые операции очереди
Методы push_front()/push_back() - операции с двух сторон дека

Структура: Приоритетная очередь

В Python:
PriorityQueue из queue - готовая реализация приоритетной очереди

В Java:
PriorityQueue класс из java.util - основная реализация
Естественный порядок или компаратор - способы задания приоритета
Min-Heap по умолчанию - наименьший элемент имеет высший приоритет

В C++:
priority_queue из <queue> - стандартная реализация
Max-Heap по умолчанию - наибольший элемент имеет высший приоритет



Лабораторная №3:

Структура: Бинарная куча (Binary Heap)

Python:
heapq модуль - реализация min-heap
Методы heappush(), heappop() - добавление/извлечение
Min-heap по умолчанию - наименьший элемент имеет высший приоритет

Java:
PriorityQueue класс из java.util - на основе бинарной кучи
Min-heap по умолчанию
Методы offer(), poll() - добавление,извлечение
Естественный порядок или компаратор для сортировки

C++:
priority_queue адаптер из <queue> - на основе бинарной кучи
Max-heap по умолчанию - наибольший элемент имеет высший приоритет
Методы push(), pop(), top() - основные операции
Кастомные компараторы для изменения порядка

Структура: Биномиальная куча (Binomial Heap)

Python:
Нет стандартной реализации в библиотеке
Ручная реализация через классы биномиальных деревьев

Java:
Нет в стандартной библиотеке
Рализуется вручную

C++:
Нет стандартной реализации
Сложная ручная реализация с указателями
Эффективное объединение куч за O(log n)

Структура: Куча Фибоначчи (Fibonacci Heap)

Python:
Нет в стандартной библиотеке

Java:
Нет прямой реализации в JDK

C++:
Нет стандартной реализации
Теоретическая структура со сложной реализацией
