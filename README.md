Сортировка выбором

Определение:
Сортировка выбором — это алгоритм, который последовательно находит минимальные (или максимальные) элементы в неотсортированной части массива и помещает их в нужное место.

Анализ:
Начало:Берём первый элемент массива и принимаем его за минимальный.
Поиск:Просматриваем остальные элементы массива и находим настоящий минимальный элемент.
Замена:Меняем найденный минимальный элемент с текущим.
Повторение:Продолжаем повторять процесс, начиная со следующего элемента, пока весь массив не станет отсортированным.

Временная сложность: O(n^2)
Почему: Каждый элемент сравнивается со всеми последующими элементами, количество сравнений растёт пропорционально количеству элементов, даже в самом благоприятном сценарии (уже отсортированном массиве) придётся сделать столько же проходов, потому что внутренние сравнения обязательны.


Сортировка обменом(пузырьком)

Определение:
Сортировка пузырьком — это алгоритм, который последовательно сравнивает соседние элементы массива и меняет их местами, если они расположены неправильно, повторяя процесс до полной сортировки.

Анализ:
Шаг 1: Просматриваем массив, сравнивая первые два элемента и меняя их местами, если первый больше второго.
Шаг 2: Продолжаем двигаться по массиву, сравнивая и меняя местами соседние элементы.
Шаг 3: За один полный проход наибольшее ("самое тяжёлое") значение "всплывает" в конец массива.
Шаг 4: Повторяем шаги 1—3, каждый раз сужая зону сортировки, пока весь массив не будет отсортирован.

Временная сложность: O(n^2)
Почему: Из-за двойного цикла: внешний цикл проходит по массиву n−1 раз, а внутренний цикл проходит по остаткам массива, делая суммарно около (n^2)/2 сравнений и обменов.
Даже если массив уже отсортирован, алгоритм все равно выполнит хотя бы один полный проход (хоть и сможет остановиться раньше при правильной оптимизации).


Сортировка вставками

Определение:
Сортировка вставками — это алгоритм, который последовательно берёт очередной элемент массива и вставляет его на нужную позицию в уже отсортированной части массива.

Анализ:
Шаг 1: Предполагаем, что первый элемент массива уже отсортирован.
Шаг 2: Берем второй элемент и сравниваем его с первым, если надо, меняем их местами.
Шаг 3: Берём третий элемент и ставим его на правильную позицию среди первых двух элементов.
Шаг 4: Повторяем шаги 2 и 3 для последующих элементов, пока весь массив не будет отсортирован.

Временная сложность: O(n^2)
Почему:
Самый плохой случай возникает, когда массив отсортирован в обратном порядке, и каждый элемент приходится вставлять далеко влево, совершая много сравнений и сдвигов.
Средняя и лучшая ситуация зависит от степени предварительного порядка массива, но в любом случае временные затраты растут пропорционально квадрату размера массива.


Сортировка слиянием

Определение:
Сортировка слиянием — это алгоритм, который разделяет массив на небольшие части, сортирует их, а затем соединяет (сливает) отсортированные части обратно в один общий отсортированный массив.

Анализ:
Шаг 1: Массив разделяется на две примерно одинаковые части.
Шаг 2: Эти части рекурсивно сортируются аналогичным способом.
Шаг 3: Уже отсортированные части объединяются обратно в один большой отсортированный массив.
Шаг 4: Шаги 1—3 повторяются до тех пор, пока весь массив не будет отсортирован.

Временная сложность: O(n*log(n))
Почему: Каждый раз массив делится на две части, что создает дерево глубиной log(n).
Каждое слияние половинок требует O(n) операций, так как нужно сравнить и объединить все элементы.
Всего уровней дерева будет log(n), и на каждом уровне выполняется O(n) операций.
Общая временная сложность получается O(n*log(n))


Сортировка Шелла

Определение: 
Сортировка Шелла — это усовершенствованный алгоритм сортировки вставками, который вначале группирует элементы на определённом расстоянии друг от друга и сортирует эти группы, постепенно уменьшая расстояние между элементами.

Анализ:
Шаг 1: Массив делится на группы элементов, находящихся на фиксированном расстоянии друг от друга (называемом шагом).
Шаг 2: Каждая группа сортируется индивидуально методом вставок.
Шаг 3: Расстояние между группами постепенно уменьшается, и процедура повторяется.
Шаг 4: Когда расстояние достигает единицы, выполняется обычная сортировка вставками над всем массивом.

Временная сложность: O(n^(3/2))
Почему:
Изначально сортируются отдельные группы элементов, что ускоряет процесс.
Постепенное уменьшение расстояния повышает эффективность, так как позже требуется меньше сравнений и перемещений.
Итоговая сложность улучшается за счёт того, что сортировка проводится на разных уровнях детализации.


Быстрая сортировка

Определение:
Быстрая сортировка (Quicksort) — это высокоэффективный алгоритм сортировки, использующий стратегию «разделяй и властвуй»: массив делится на две части относительно опорного элемента (pivot), затем каждая часть сортируется отдельно.

Анализ:
Шаг 1: Выбираем опорный элемент (обычно последний элемент массива).
Шаг 2: Переносим все элементы, меньшие опорного, в левую сторону, а большие — в правую.
Шаг 3: Опорный элемент размещается на границе между этими двумя частями.
Шаг 4: Применяем тот же процесс рекурсивно к левой и правой частям массива.
Шаг 5: Процесс повторяется, пока весь массив не будет отсортирован.

Временная сложность: O(n*log(n))
Почему:
Алгоритм постоянно делит массив на две части (рекурсия), что соответствует двоичному дереву глубины logn.
На каждом уровне рекурсии выполняются O(n) операций для перераспределения элементов.
В результате итоговая сложность оценивается как O(nlogn).


Пирамидальная сортировка

Определение:
Пирамиджальная сортировка - это алгоритм сортировки, который использует структуру данных, называемую кучей (heap), для эффективного нахождения максимального (или минимального) элемента и построения отсортированного массива.

Анализ:
Шаг 1: Формируем max-кучу из массива (строим структуру, где каждый родительский элемент больше обоих своих детей).
Шаг 2: Замечаем, что вершина кучи (первая позиция массива) содержит максимальный элемент.
Шаг 3: Помещаем максимальный элемент в конец массива, удаляя его из кучи.
Шаг 4: Повторяем шаги 1-3, пока не останется элементов.

Временная сложность: O(n*log(n))


Последовательный поиск

Определение:
Последовательный поиск - это простой алгоритм поиска, который последовательно проверяет каждый элемент массива, пока не найдет требуемое значение или не достигнет конца массива.

Анализ:
Шаг 1: Начинаем с первого элемента массива.
Шаг 2: Сравниваем текущий элемент с искомым значением.
Шаг 3: Если элемент найден, возвращаем его индекс.
Шаг 4: Если элемент не найден, переходим к следующему элементу.
Шаг 5: Повторяем шаги 2-4, пока не дойдем до конца массива.

Временная сложность: O(n)
Почему:
В худшем случае (искомый элемент отсутствует или находится в конце массива) алгоритм должен просмотреть все n элементов.
В лучшем случае (элемент находится в первом положении) потребуется всего одна проверка.
В среднем случае ожидаемое количество проверок — около n/2, что все равно ведет к линейной сложности O(n).


Бинарный поиск

Определение:
Бинарный поиск  - это алгоритм поиска элемента в отсортированном массиве путём последовательного сокращения области поиска наполовину на каждом шаге.

Анализ:
Шаг 1: Устанавливаем границы поиска: начинаем с левой и правой сторон массива.
Шаг 2: Находим среднее значение между границами.
Шаг 3: Сравниваем искомое значение с средним элементом:
Если средние равны, элемент найден.
Если искомое значение меньше среднего, повторяем поиск в левой половине.
Если искомое значение больше среднего, повторяем поиск в правой половине.
Шаг 4: Повторяем шаги 2-3, пока элемент не будет найден или область поиска не сократится до пустоты.

Временная сложность: O(log(n))
Почему:
Каждый шаг сокращает область поиска вдвое.
Чем больше массив, тем дольше идет сокращение, но число шагов логарифмически зависит от размера массива.
В итоге алгоритм способен находить элемент за логарифмическое время, что намного быстрее линейного поиска.



Интерполирующий поиск

Определение:
Интерполирующий поиск - это
