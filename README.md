Сортировка выбором

Определение:
Сортировка выбором — это алгоритм, который последовательно находит минимальные (или максимальные) элементы в неотсортированной части массива и помещает их в нужное место.

Анализ:
Находим минимальный элемент:Используем вложенные циклы for, чтобы найти минимальный элемент в неотсортированной части массива.
Меняем местами:С помощью оператора swap() меняем найденный минимальный элемент с первым элементом неотсортированной части.
Повторяем процесс:Продвигаясь по массиву, каждый раз уменьшаем неотсортированную часть

Временная сложность: O(n^2)
Почему: Каждый элемент сравнивается со всеми последующими элементами, количество сравнений растёт пропорционально количеству элементов, даже в самом благоприятном сценарии (уже отсортированном массиве) придётся сделать столько же проходов, потому что внутренние сравнения обязательны.


Сортировка обменом(пузырьком)

Определение:
Сортировка пузырьком — это алгоритм, который последовательно сравнивает соседние элементы массива и меняет их местами, если они расположены неправильно, повторяя процесс до полной сортировки.

Анализ:
Просматриваем массив:Используем вложенные циклы for, где внутренний цикл сравнивает соседние элементы.
Меняем местами элементы:Если соседние элементы идут в неправильном порядке, меняем их с помощью оператора swap().
Продолжаем проходить массив:Внешний цикл продолжает вызывать внутренний цикл до тех пор, пока массив не будет отсортирован.

Временная сложность: O(n^2)
Почему: Из-за двойного цикла: внешний цикл проходит по массиву n−1 раз, а внутренний цикл проходит по остаткам массива, делая суммарно около (n^2)/2 сравнений и обменов.
Даже если массив уже отсортирован, алгоритм все равно выполнит хотя бы один полный проход (хоть и сможет остановиться раньше при правильной оптимизации).


Сортировка вставками

Определение:
Сортировка вставками — это алгоритм, который последовательно берёт очередной элемент массива и вставляет его на нужную позицию в уже отсортированной части массива.

Анализ:
Выделяем отсортированную часть:Один цикл for проходит по массиву, считая первые элементы уже отсортированными.
Вставляем элементы на место:Второй цикл (обычно while) продвигает текущий элемент влево, пока не найдёт его правильное место.
Продвигаемся по массиву:Поэтапно добавляем элементы в отсортированную часть.

Временная сложность: O(n^2)
Почему:
Самый плохой случай возникает, когда массив отсортирован в обратном порядке, и каждый элемент приходится вставлять далеко влево, совершая много сравнений и сдвигов.
Средняя и лучшая ситуация зависит от степени предварительного порядка массива, но в любом случае временные затраты растут пропорционально квадрату размера массива.


Сортировка слиянием

Определение:
Сортировка слиянием — это алгоритм, который разделяет массив на небольшие части, сортирует их, а затем соединяет (сливает) отсортированные части обратно в один общий отсортированный массив.

Анализ:
Рекурсивно делим массив:Используйте рекурсию, чтобы поделить массив на две равные части, пока каждая часть не станет минимальной.
Сливаем отсортированные части:Специальная функция слияния (merge()) комбинирует отсортированные части обратно в один массив.
Работаем рекурсивно:Продолжаем рекурсивно вызывать сортировку для каждой части массива.

Временная сложность: O(n*log(n))
Почему: Каждый раз массив делится на две части, что создает дерево глубиной log(n).
Каждое слияние половинок требует O(n) операций, так как нужно сравнить и объединить все элементы.
Всего уровней дерева будет log(n), и на каждом уровне выполняется O(n) операций.
Общая временная сложность получается O(n*log(n))


Сортировка Шелла

Определение: 
Сортировка Шелла — это усовершенствованный алгоритм сортировки вставками, который вначале группирует элементы на определённом расстоянии друг от друга и сортирует эти группы, постепенно уменьшая расстояние между элементами.

Анализ:
Начинаем с большого шага:Выбираем шаг (разрыв между элементами), который постепенно уменьшается.
Сортировка вставками с шагом:Используем сортировку вставками, но применяем её не ко всем элементам, а только к тем, которые находятся на определенном расстоянии друг от друга.
Постепенно уменьшаем шаг:Каждый раз уменьшаем шаг, пока он не станет равным единице.

Временная сложность: O(n^(3/2))
Почему:
Изначально сортируются отдельные группы элементов, что ускоряет процесс.
Постепенное уменьшение расстояния повышает эффективность, так как позже требуется меньше сравнений и перемещений.
Итоговая сложность улучшается за счёт того, что сортировка проводится на разных уровнях детализации.


Быстрая сортировка

Определение:
Быстрая сортировка (Quicksort) — это высокоэффективный алгоритм сортировки, использующий стратегию «разделяй и властвуй»: массив делится на две части относительно опорного элемента (pivot), затем каждая часть сортируется отдельно.

Анализ:
Выбираем опорный элемент:Случайно выбираем элемент (pivot) и располагаем его в центре массива.
Разделяем массив:Однопроходный цикл (for) переставляет элементы так, чтобы все элементы меньше pivot оказались слева, а больше — справа.
Рекурсивно сортируем обе части:Повторяем процесс для каждой из образовавшихся частей.

Временная сложность: O(n*log(n))
Почему:
Алгоритм постоянно делит массив на две части (рекурсия), что соответствует двоичному дереву глубины logn.
На каждом уровне рекурсии выполняются O(n) операций для перераспределения элементов.
В результате итоговая сложность оценивается как O(nlogn).


Пирамидальная сортировка

Определение:
Пирамидальная сортировка - это алгоритм сортировки, который использует структуру данных, называемую кучей (heap), для эффективного нахождения максимального (или минимального) элемента и построения отсортированного массива.

Анализ:
Преобразуем массив в кучу:С помощью функции heapify() превращаем массив в бинарную кучу (heap).
Удаляем вершины:На каждом шаге удаляем наибольший элемент (вершина кучи) и восстанавливаем кучу.
Записываем отсортированный массив:Заносим извлечённые элементы в конец массива.

Временная сложность: O(n*log(n))
Почему: Формирование начальной кучи занимает O(n) операций.
Удаление каждого элемента и восстановление структуры кучи требует O(logn) оп


Последовательный поиск

Определение:
Последовательный поиск - это простой алгоритм поиска, который последовательно проверяет каждый элемент массива, пока не найдет требуемое значение или не достигнет конца массива.

Анализ:
Проходим по массиву:Цикл for последовательно проверяет каждый элемент массива.
Сравниваем с искомым значением:Оператором == проверяем, равен ли текущий элемент искомому.
Возвращаем результат:Если элемент найден, возвращаем его индекс, иначе — специальный маркер (например, -1).

Временная сложность: O(n)
Почему:
В худшем случае (искомый элемент отсутствует или находится в конце массива) алгоритм должен просмотреть все n элементов.
В лучшем случае (элемент находится в первом положении) потребуется всего одна проверка.
В среднем случае ожидаемое количество проверок — около n/2, что все равно ведет к линейной сложности O(n).


Бинарный поиск

Определение:
Бинарный поиск  - это алгоритм поиска элемента в отсортированном массиве путём последовательного сокращения области поиска наполовину на каждом шаге.

Анализ:
Находим середину массива:Рассчитываем среднюю точку (mid = (low + high) / 2) и сравниваем её с искомым значением.
Сужаем диапазон поиска:Если средний элемент меньше искомого, меняем нижнюю границу (low = mid + 1). Если больше — меняем верхнюю (high = mid - 1).
Продолжаем поиск:Повторяем процесс, пока не найдем элемент или не закончится диапазон поиска.

Временная сложность: O(log(n))
Почему:
Каждый шаг сокращает область поиска вдвое.
Чем больше массив, тем дольше идет сокращение, но число шагов логарифмически зависит от размера массива.
В итоге алгоритм способен находить элемент за логарифмическое время, что намного быстрее линейного поиска.



Интерполирующий поиск

Определение:
Интерполирующий поиск - это расширенный алгоритм поиска, предназначенный для работы с отсортированными массивами, в котором следующая позиция для проверки рассчитывается на основе распределения элементов массива, что позволяет быстрее достичь искомого значения.

Анализ:
Определяем шаг:Используем формулу для интерполяционного расчёта, чтобы найти ближайшую позицию возможного появления элемента.
Проверяем точность попадания:Если текущая позиция верна, возвращаем её. Если нет — сужаем диапазон поиска.
Продолжаем поиск:Повторяем шаги, пока не найдем элемент или не исчерпаем диапазон поиска.


Временная сложность: O(log(log(n)))
Почему:
Алгоритм полагается на предположение о равномерном распределении элементов, что позволяет быстро вычислить приблизительную позицию искомого элемента.
В удачных условиях (при равномерном распределении) алгоритм резко сокращает пространство поиска, достигая логарифмической скорости, основанной на логарифме логарифма.


Поиск по Фибоначчи

Определение:
Поиск по Фибоначчи - это aлгоритм поиска в отсортированном массиве, использующий числа Фибоначчи для определения следующей позиции для проверки, что позволяет сократить пространство поиска и ускорить процесс.

Анализ:
Готовим ряд Фибоначчи:Генерируем числа Фибоначчи, достаточные для покрытия размера массива.
Пользуемся свойствами Фибоначчи:Делим массив на сегменты, руководствуясь рядом Фибоначчи, и ищем элемент в соответствующем сегменте.
Продолжаем поиск:Подобно бинарному поиску, но с сегментами, соответствующими ряду Фибоначчи.

Временная сложность: O(log(n))
Почему:
Алгоритм использует ряд Фибоначчи для сокращения пространства поиска, аналогично бинарному поиску.
Каждый шаг существенно уменьшает размер исследуемой области, приводя к логарифмическому времени поиска.
