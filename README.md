Сортировка выбором

Определение:
Сортировка выбором — это алгоритм, который последовательно находит минимальные (или максимальные) элементы в неотсортированной части массива и помещает их в нужное место.

Анализ:
Алгоритм находит минимальный элемент в неотсортированной части массива и меняет его местами с первым элементом в неотсортированной части.
Внешний цикл for выполняется n-1 раз.
Внутренний цикл for в худшем случае выполняется n-1, затем n-2, ..., раз за каждый проход внешнего цикла.
Общее количество сравнений примерно равно (n*(n-1))/2.

Временная сложность: O(n^2)
Почему: Каждый элемент сравнивается со всеми последующими элементами, количество сравнений растёт пропорционально количеству элементов, даже в самом благоприятном сценарии (уже отсортированном массиве) придётся сделать столько же проходов, потому что внутренние сравнения обязательны.


Сортировка обменом(пузырьком)

Определение:
Сортировка пузырьком — это алгоритм, который последовательно сравнивает соседние элементы массива и меняет их местами, если они расположены неправильно, повторяя процесс до полной сортировки.

Анализ:
Внешний цикл for проходит по массиву n-1 раз.
Внутренний цикл for сравнивает соседние элементы и меняет их местами, если они расположены неверно.
В худшем случае внутренний цикл выполняется n-1, затем n-2, ..., раз за каждый проход внешнего цикла.
Общее количество сравнений и обменов примерно равно (n*(n-1))/2.

Временная сложность: O(n^2)
Почему: Из-за двойного цикла: внешний цикл проходит по массиву n−1 раз, а внутренний цикл проходит по остаткам массива, делая суммарно около (n^2)/2 сравнений и обменов.
Даже если массив уже отсортирован, алгоритм все равно выполнит хотя бы один полный проход (хоть и сможет остановиться раньше при правильной оптимизации).


Сортировка вставками

Определение:
Сортировка вставками — это алгоритм, который последовательно берёт очередной элемент массива и вставляет его на нужную позицию в уже отсортированной части массива.

Анализ:
Внешний цикл for проходит по массиву, начиная со второго элемента, и пытается вставить его на правильное место среди уже отсортированных элементов.
Внутренний цикл while продвигает элементы вправо, пока не найдёт правильное место для вставки.
В худшем случае внутренний цикл проходит по всей отсортированной части массива (до первого элемента), следовательно, общее количество сравнений и перемещений может достигнуть примерно (n*(n-1))/2.

Временная сложность: O(n^2)
Почему:
Самый плохой случай возникает, когда массив отсортирован в обратном порядке, и каждый элемент приходится вставлять далеко влево, совершая много сравнений и сдвигов.
Средняя и лучшая ситуация зависит от степени предварительного порядка массива, но в любом случае временные затраты растут пропорционально квадрату размера массива.


Сортировка слиянием

Определение:
Сортировка слиянием — это алгоритм, который разделяет массив на небольшие части, сортирует их, а затем соединяет (сливает) отсортированные части обратно в один общий отсортированный массив.

Анализ:
Используется рекурсивный подход с функциями divideAndConquer и mergeHalves.
Массив рекурсивно делится на две части до тех пор, пока каждая часть не станет размером 1.
Затем происходит слияние (функция mergeHalves), где два отсортированных массива объединяются в один.

Временная сложность: O(n*log(n))
Почему: Каждый раз массив делится на две части, что создает дерево глубиной log(n).
Каждое слияние половинок требует O(n) операций, так как нужно сравнить и объединить все элементы.
Всего уровней дерева будет log(n), и на каждом уровне выполняется O(n) операций.
Общая временная сложность получается O(n*log(n))


Сортировка Шелла

Определение: 
Сортировка Шелла — это усовершенствованный алгоритм сортировки вставками, который вначале группирует элементы на определённом расстоянии друг от друга и сортирует эти группы, постепенно уменьшая расстояние между элементами.

Анализ:
Основную роль играет двойной цикл for, где внешний цикл устанавливает шаг (gap), а внутренний перемещает элементы на соответствующие позиции.
Первый цикл проходит по шагам (начиная с большого промежутка и заканчивая единицей).
Второй цикл (внутренний) "перепрыгивает" элементы на установленный шаг и расставляет их по местам.

Временная сложность: O(n^(3/2))
Почему:
Изначально сортируются отдельные группы элементов, что ускоряет процесс.
Постепенное уменьшение расстояния повышает эффективность, так как позже требуется меньше сравнений и перемещений.
Итоговая сложность улучшается за счёт того, что сортировка проводится на разных уровнях детализации.


Быстрая сортировка

Определение:
Быстрая сортировка (Quicksort) — это высокоэффективный алгоритм сортировки, использующий стратегию «разделяй и властвуй»: массив делится на две части относительно опорного элемента (pivot), затем каждая часть сортируется отдельно.

Анализ:
Основная задача — разделить массив на две части относительно опорного элемента (pivot).
Функции partition и quickSort работают совместно.
Опорная точка (pivot) выделяется, а затем элементы располагаются так, чтобы все меньшие находились слева, а большие — справа.
Алгоритм рекурсивно повторяется для каждой части массива.

Временная сложность: O(n*log(n))
Почему:
Алгоритм постоянно делит массив на две части (рекурсия), что соответствует двоичному дереву глубины logn.
На каждом уровне рекурсии выполняются O(n) операций для перераспределения элементов.
В результате итоговая сложность оценивается как O(nlogn).


Пирамидальная сортировка

Определение:
Пирамидальная сортировка - это алгоритм сортировки, который использует структуру данных, называемую кучей (heap), для эффективного нахождения максимального (или минимального) элемента и построения отсортированного массива.

Анализ:
Используются две главные фазы: построение кучи (heapify) и извлечение корней.
Массив преобразуется в "кучу" (структуру, где родитель всегда больше своих детей).
Корень кучи (наибольшее значение) вытаскивается и отправляется в конец массива.
Структура кучи перестраивается после удаления корня.
Повторяется удаление и перестроение, пока массив не будет отсортирован.

Временная сложность: O(n*log(n))
Почему: Формирование начальной кучи занимает O(n) операций.
Удаление каждого элемента и восстановление структуры кучи требует O(logn) оп


Последовательный поиск

Определение:
Последовательный поиск - это простой алгоритм поиска, который последовательно проверяет каждый элемент массива, пока не найдет требуемое значение или не достигнет конца массива.

Анализ:
Очередной элемент массива сравнивается с искомым значением.
Цикл for проходит по массиву, пока не встретит искомое значение или не закончатся элементы.
Если элемент найден, возвращается его индекс, иначе — специальная метка (например, -1).

Временная сложность: O(n)
Почему:
В худшем случае (искомый элемент отсутствует или находится в конце массива) алгоритм должен просмотреть все n элементов.
В лучшем случае (элемент находится в первом положении) потребуется всего одна проверка.
В среднем случае ожидаемое количество проверок — около n/2, что все равно ведет к линейной сложности O(n).


Бинарный поиск

Определение:
Бинарный поиск  - это алгоритм поиска элемента в отсортированном массиве путём последовательного сокращения области поиска наполовину на каждом шаге.

Анализ:
Массив должен быть отсортирован.
Серединный элемент сравнивается с искомым значением.
Если срединный элемент меньше, поиск продолжается в правой половине; если больше — в левой.
Происходит постоянное деление массива пополам, пока не найдём элемент или не выясним, что его нет.

Временная сложность: O(log(n))
Почему:
Каждый шаг сокращает область поиска вдвое.
Чем больше массив, тем дольше идет сокращение, но число шагов логарифмически зависит от размера массива.
В итоге алгоритм способен находить элемент за логарифмическое время, что намного быстрее линейного поиска.



Интерполирующий поиск

Определение:
Интерполирующий поиск - это расширенный алгоритм поиска, предназначенный для работы с отсортированными массивами, в котором следующая позиция для проверки рассчитывается на основе распределения элементов массива, что позволяет быстрее достичь искомого значения.

Анализ:
Массив должен быть отсортирован.
Серединный элемент сравнивается с искомым значением.
Если срединный элемент меньше, поиск продолжается в правой половине; если больше — в левой.
Происходит постоянное деление массива пополам, пока не найдём элемент или не выясним, что его нет.

Временная сложность: O(log(log(n)))
Почему:
Алгоритм полагается на предположение о равномерном распределении элементов, что позволяет быстро вычислить приблизительную позицию искомого элемента.
В удачных условиях (при равномерном распределении) алгоритм резко сокращает пространство поиска, достигая логарифмической скорости, основанной на логарифме логарифма.


Поиск по Фибоначчи

Определение:
Поиск по Фибоначчи - это aлгоритм поиска в отсортированном массиве, использующий числа Фибоначчи для определения следующей позиции для проверки, что позволяет сократить пространство поиска и ускорить процесс.

Анализ:
Используется ряд Фибоначчи для определения ближайшей возможной позиции элемента.
Массив делится на части в соответствии с рядом Фибоначчи.
Искомое значение сравнивается с элементом в середине выделенной части.
Часть массива отбрасывается, и поиск продолжается в оставшемся участке.

Временная сложность: O(log(n))
Почему:
Алгоритм использует ряд Фибоначчи для сокращения пространства поиска, аналогично бинарному поиску.
Каждый шаг существенно уменьшает размер исследуемой области, приводя к логарифмическому времени поиска.
