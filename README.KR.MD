Контрольная работа

Блочная(корзинная) сортировка

Определение:
Блочная сортировка - это алгоритм, который распределяет элементы исходного массива на несколько блоков (корзин) в зависимости от диапазона их
значений. После этого каждая корзина сортируется отдельно (либо тем же методом
рекурсивно, либо другим алгоритмом, например, вставками), и отсортированные корзины
объединяются обратно в один массив.

Анализ:
Делим массив на баки:Используем оператор std::vector<std::vector<T>>(), чтобы создать вектор контейнеров (баков), где каждый бак — это будущий мини-массив для сортировки.
Распределяем элементы по бакам:В цикле for пробегаем по массиву и размещаем каждый элемент в соответствующий бак, вычисляя его принадлежность через простую формулу.
Сортируем каждый бак:Применяем функцию std::sort() к каждому баку, чтобы отсортировать его локально.
Складываем отсортированные элементы обратно в массив:Итоговый цикл собирает отсортированные элементы из каждого бака обратно в исходный массив.

Временная сложность: O(n+k), где n — количество элементов массива, k — количество созданных баков.
Почему: Первым делом мы распределяем элементы по бакам за время O(n).
Затем каждый бак сортируется отдельно, и если баки сравнительно небольшого размера, то на это уходит примерно O(k).
На завершающем этапе мы снова пробегаем по всем бакам и собираем элементы обратно в массив, что добавляет еще 
O(n).

Сортировка бусинами(гравитационная)

Определение:
Сортировка бусинами (bead sort), также известная как гравитационная
сортировка, моделирует естественное поведение бусин, падающих вниз под действием
гравитации. 

Анализ:
Находим максимальную высоту:Используем оператор std::max_element() для поиска наибольшего числа в массиве.
Создаем матрицу бусин:Оператор std::vector<std::vector<bool>>() строит матрицу, где каждый столбец — элемент массива, а высота столбца — значение элемента.
Заполняем матрицу бусин:Вложенные циклы for размечают матрицу в соответствии с числами массива.
Имитация падения бусин:Следующие циклы моделируют движение бусин вниз, устанавливая их на нужные позиции.
Восстанавливаем отсортированный массив:Последний цикл собирает количество бусин в каждом столбце, создавая отсортированный массив.

Временная сложность: O(n*(k^0.5)), где n — количество элементов массива, k — разница между максимальным и минимальным значениями.
Почему: Визуально алгоритм кажется быстрым, так как бусины мгновенно стабилизируются, но фактически сложность зависит от диапазона значений.
Для каждого элемента требуется организовать "падение" бусин, что приводит к временным затратам, зависящим от диапазона данных.


