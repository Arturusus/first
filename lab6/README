Вариант 17. Имитация отжига для решения системы нелинейных уравнений
Задача: использовать имитацию отжига для решения системы уравнений:
x² + y² = 25
x + y = 7
Требования:
- Целевая функция: (x² + y² - 25)² + (x + y - 7)²
- Начальное решение: случайные x, y из [-10, 10]
- Вывести найденное решение
Входные данные:
Диапазон: [-10, 10] для обеих переменных

Анализ работы алгоритма:
Целевая функция (objective_function): вычисляет отклонение от системы уравнений.
Генерация случайных чисел (rand_in_range): использует std::default_random_engine и std::uniform_real_distribution для генерации случайных чисел.
Функция clamp: ограничивает значения в диапазоне [−10,10] с помощью std::min и std::max.
Имитация отжига (simulated_annealing):  
-начальное состояние:Случайные x и y с помощью rand_in_range.
-цикл:  
Генерируются случайные возмущения dx и dy с помощью rand_in_range, значения x и y ограничиваются с помощью clamp, вычисляется новая целевая функция с помощью objective_function. 
Если новое состояние лучше, оно принимается. Если хуже, принимается с вероятностью, зависящей от температуры. Температура уменьшается на каждом шаге.
-главная функция (main): устанавливает параметры имитации отжига и запускает её.

Временная сложность: O(n)
Почему:
Алгоритм выполняет фиксированное количество итераций, заданное параметром iterations.
На каждой итерации выполняются операции с фиксированной сложностью:
Генерация случайных чисел (rand_in_range).
Вычисление целевой функции (objective_function).
Сравнение и обновление переменных.

Контрольный вопрос:
Метод ближайшего соседа с улучшением (TSP)
Условие. Построить маршрут TSP методом ближайшего соседа, затем улучшить его 2‑opt.
Алгоритм: комбинация «ближайший сосед» + 2‑opt.
Язык примера: Python
def tsp_hybrid(dist):
 n = len(dist)
 # Шаг 1: ближайший сосед
 path = [0]
 visited = [False] * n
 visited[0] = True
 for _ in range(n - 1):
 curr = path[-1]
 next_city = -1
 # ДОПИСАТЬ: найти ближайший непосещённый город
 path.append(next_city)
 visited[next_city] = True
 # Шаг 2: 2-opt улучшение
 path = twoOpt(path, dist) # использовать функцию из Задания 3
 return path
Что дописать: поиск next_city по минимуму dist[curr][j] среди непосещённых.

Ответ на контрольный вопрос:
next_city = min((j for j in range(n) if not visited[j]), key=lambda j: dist[curr][j])
